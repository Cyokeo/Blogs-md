---
title: 对话-内存屏障
---

## 一
IT知识刺客:
你好，欢迎关注IT知识刺客！

深蓝:
老师您好，最近看了您的《HPC-一文彻底搞懂并发编程与内存屏障》系列文章，收获颇多。有个问题想请教一下您，考虑在X64架构下手动实现一个多核使用的自旋锁。
1. 这应该是一个load store的访存顺序模型；
2. 考虑初始时自旋锁变量为0；
3. core 0 load 发现是0 (t0)；判断为0(t1)；继续执行store 1(t2)；1被写入主存(t3); 进入关键区
4. core1在t4时刻也尝试获取自旋锁，因此它也load

------------------

如果t4处于t2-t3，有可能拿到自己缓存中的旧值0，之后执行store 1操作；接着也会进入关键区。这里明显是有问题的，因此需要在load 之前加内存屏障，确保拿数据前其它CPU的写操作都执行完成；这里不符合“写我的，读你的”场景，但是好像也要使用内存屏障消除MESI的同步延迟。是我哪里理解错了嘛？烦请老师指点~

------

如果t4处于t0-t1/t2之间，那么core0的load也会返回0，因此它也尝试执行store。这里会有碰撞，因该要使用您前文里说的lock进行；这里有个疑问：如果后来的core1的store没有获取总线锁，那core会采取什么操作呢？
1. 继续等待，直到写成功嘛？但是感觉也有问题，因为已经是1了，我后续写1成功，但是app后续都会进入关键区
2. 返回失败。这样感觉可以，但是CPU如何通知汇编程序员？难道store后，还需要检查某些系统寄存器的状态位？ -> 
3. 这种情况感觉是会发生的，老师可以推荐些相关资料嘛？

- ！！因此store 1操作也要使用屏障，确保写操作完成
	- 详细看一下arm64的`DSB`内存屏障指令


