---
title: 内联汇编
categories: 嵌入式-开发
---
## 参考文档
- [内联汇编](https://github.com/1184893257/simplelinux/blob/master/inlineasm.md)
- [gcc 内联汇编 HOWTO 文档](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)  
- [Linux Cross Reference——各版本 linux 内核函数检索](http://lxr.free-electrons.com/ident)

内联汇编是指在 C/C++ 代码中嵌入的汇编代码， 与全部是汇编的汇编源文件不同，它们被嵌入到 C/C++ 的大环境中。

## 一、gcc 内联汇编

gcc 内联汇编的格式如下：

```
asm ( 汇编语句
    : 输出操作数		// 非必需
    : 输入操作数		// 非必需
    : 其他被污染的寄存器	// 非必需
    );
```

我们通过一个简单的例子来了解一下它的格式（gcc_add.c）：

```
#include <stdio.h>

int main()
{
	int a=1, b=2, c=0;

	// 蛋疼的 add 操作
	asm(
		"addl %2, %0"		// 1
		: "=g"(c)			// 2
		: "0"(a), "g"(b)	// 3
		: "memory");		// 4

	printf("现在c是:%d\n", c);
	return 0;
}
```

内联汇编中：

1. 第1行是汇编语句，用双引号引起来， **多条语句用 ; 或者 `\n\t` 来分隔。**
	- %0 - 2中的数字表示输出，输出操作数，从前往后

3. 第2行是输出操作数，都是 "=?"(var) 的形式， var 可以是任意内存变量（输出结果会存到这个变量中）， ? 一般是下面这些标识符 （表示内联汇编中用什么来代理这个操作数）：
    
    - a,b,c,d,S,D 分别代表 eax,ebx,ecx,edx,esi,edi 寄存器
    - r 上面的寄存器的任意一个（谁闲着就用谁）
    - m 内存
    - i 立即数（常量，只用于输入操作数）
    - g 寄存器、内存、立即数 都行（gcc你看着办）
    
    **在汇编中用 %序号 来代表这些输入/输出操作数， 序号从 0 开始。为了与操作数区分开来， 寄存器用两个%引出，如：%%eax**
    
3. 第3行是输入操作数，都是 "?"(var) 的形式， **? 除了可以是上面的那些标识符，还可以是输出操作数的序号， 表示用 var 来初始化该输出操作数**， 上面的程序中 %0 和 %1 就是一个东西，初始化为 1（a的值）。
4. 第4行标出那些在汇编代码中修改了的、 又没有在输入/输出列表中列出的寄存器， 这样 gcc 就不会擅自使用这些"危险的"寄存器。 还可以用 "memory" 表示在内联汇编中修改了内存， 之前缓存在寄存器中的内存变量需要重新读取。

上面这一段内联汇编的效果就是， 把a与b的和存入了c。当然这只是一个示例程序， 谁要真这么用就蛋疼了， **内联汇编一般在不得不用的情况下才使用**。