---
title: cpp-基础扫盲
tags:
  - 面经
---
- 从管理数据的角度理解cpp
- 
- 定义位于类声明中的函数都将自动成为内联函数
	- 定义在类声明外部的，也可使用inline限定符使其成为内联的；类内声明无需加上inline限定符

- 类中的***函数不占用类/对象的内存空间***，即使用sizeof()结果不受类中成员函数的影响，仅与数据部分相关
	- ***想想：确实应该是这样的***
	- 但是含有虚函数的话，可能含有额外的虚函数表指针

- 类中的***静态成员变量也不占用类实例对象的内存空间***

- 即然对象占据的内存空间中没有成员函数的信息，对象是怎么访问到其成员函数呢？
	- 因此可以看到，普通成员函数的访问与运行时的对象没有任何关系
	- 普通成员函数的绑定 - ***完全依赖于编译器的解析与静态绑定***
	- ***编译时完全确定了***
- 对比虚函数：
	- 对象内部有虚函数表指针，因此可以访问到真实的对象对应的虚函数地址，因此可以实际调用到对象对应的虚函数

- 当程序创建未显示初始化的对象时，总是调用默认构造函数
	- 这里就记住了：
		- 声明：变量/对象，必须加上***extern***关键字

- 在类中以下面的方式声明的枚举的作用域为整个类
	```cpp
	class Bakery
	{
		private:
			enum {Month = 12};
		......
	}
	```
	- 这里并没有给出枚举的变量名，因此类中并没有这个成员变量的声明；创建的类实例对象中也没有这个这个枚举成员；`Month`只是一个符号，在作用域为整个类的代码中遇到它时，编译器将用12替换它

- extern int test_arr[]
	- `test_arr`是不完整类型，不能对其使用sizeof()操作