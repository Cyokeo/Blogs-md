---
title: 设计规范
date: 2024-07-10 18:58:01
tags:
categories:
- [日常记录]
---

## [设计规范](http://10.1.14.75/team/compass/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83)

- 使用指定长度的数据类型，需编译器提供<stdint.h>头文件，或者已知硬件芯片字长的情况下自定义

- 在结构体中，人为添加pad以实现结构体内成员的**自然对齐**，不要依赖编译器进行

- CPU间通信的数据结构中，不能包含enum类型的变量

- 静态数据表应使用const进行修饰
    - 一方面，const修饰的通常保存在flash中，节省RAM空间
    - 其次，防止数据被篡改

- 指针对齐考虑 【这个问题之前还真没有考虑过！！！】
    ```c
    uint8_t buf[4];             // -> 这里buf是1字节对齐的，即buf的值可能为0xc0080001
    uint32_t* ptr_a = buf;      // -> 这里ptr_a指向变量类型为4字节对齐，因此ptr_a要求是4字节对齐的。因此，这样赋值可能会出现问题

    ```
    - 当指针指向的内存地址不能满足指针数据类型的对齐要求时，一般情况下，指针会**向下**做对齐操作。例如指针要求4字节对齐，而指向的地址为0x80000002，指针会自动向下做对齐指向0x80000000地址。
    - 因此，遇到将小数据类型的地址赋值给大数据类型的指针变量时，要意识到可能会有这种问题的存在
    - 尤其在回调接口中，为了通用性，一般使用`uint8_t*`类型的指针，针对用户提供的该指针，后续进行类型强转时，需要先判断其是否符合类型指针对齐的要求，再进行强转操作

- 函数调用时提供函数原型很重要，尤其对于函数返回值；某些情况下，函数形参也很重要，因为涉及到参数入栈

- 独立组件模块：为了提高组件的可移植性，不允许直接使用外部变量，调用外部函数；而是通过回调函数的形式 -> 初始化时，需要向组件注册回调函数，当组件检测到相应场景时，调用相应之前注册的回调函数

- 分层设计：组件与硬件、操作系统等资源相关；将与 __硬件__ 、 __操作系统__ 等平台相关的代码独立出来，定义成**驱动层**，而与平台无关的代码定义成**核心层**。核心层与驱动层定义一套接口，__接口由核心层定义，驱动来实现__。通过上层应用将驱动层与核心层关联起来，一般采用 __函数指针__ 的方式将驱动层与核心关联起来。
