---
title: " Linux - çº¿ç¨‹èµ„æº&æ¨¡å‹"
categories: æ“ä½œç³»ç»Ÿ
---
## å‚è€ƒæ–‡ç« 
- [ä¸»çº¿ç¨‹é€€å‡ºå¯¹å­çº¿ç¨‹çš„å½±å“](https://originlee.com/2015/04/08/influence-of-main-threads-exiting-to-child-thread/)

## çº¿ç¨‹èµ„æº
åŒä¸€è¿›ç¨‹ä¸­çš„å¤šä¸ªçº¿ç¨‹ä½¿ç”¨åŒä¸€ä»½è¿›ç¨‹åœ°å€ç©ºé—´ï¼Œå› æ­¤å®ƒä»¬çš„å¤§éƒ¨åˆ†èµ„æºæ˜¯å…±äº«çš„ï¼Œæˆ‘ä»¬åªéœ€è¦è®°ä½ä¸€äº›ä¸è¢«å…±äº«çš„èµ„æºå³å¯ï¼š
- çº¿ç¨‹ID  
- ä¸€ç»„å¯„å­˜å™¨  
- æ ˆ  
- errno(é”™è¯¯ç )  
- ä¿¡å·å±è”½å­—(block)  
- è°ƒåº¦ä¼˜å…ˆçº§

## çº¿ç¨‹æ¨¡å‹
å®é™…ä¸Šï¼Œposixçº¿ç¨‹å’Œä¸€èˆ¬çš„è¿›ç¨‹ä¸åŒï¼Œåœ¨æ¦‚å¿µä¸Šæ²¡æœ‰ä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹ä¹‹åˆ†ï¼ˆè™½ç„¶åœ¨å®é™…å®ç°ä¸Šè¿˜æ˜¯æœ‰ä¸€äº›åŒºåˆ†ï¼‰ï¼Œå¦‚æœä»”ç»†è§‚å¯Ÿapueæˆ–è€…unpç­‰ä¹¦ä¼šå‘ç°åŸºæœ¬çœ‹ä¸åˆ°ã€Œä¸»çº¿ç¨‹ã€æˆ–è€…ã€Œå­çº¿ç¨‹ã€ç­‰è¯è¯­ï¼Œåœ¨csappä¸­ç”šè‡³éƒ½æ˜¯ç”¨ã€Œå¯¹ç­‰çº¿ç¨‹ã€ä¸€è¯æ¥æè¿°çº¿ç¨‹é—´çš„å…³ç³»ã€‚

åœ¨Linux 2.6ä»¥åçš„posixçº¿ç¨‹éƒ½æ˜¯ç”±ç”¨æˆ·æ€çš„pthreadåº“æ¥å®ç°çš„ã€‚åœ¨ä½¿ç”¨pthreadåº“ä»¥åï¼Œåœ¨ç”¨æˆ·è§†è§’çœ‹æ¥ï¼Œæ¯ä¸€ä¸ªtast_structå°±å¯¹åº”ä¸€ä¸ªçº¿ç¨‹ï¼ˆtast_structåŸæœ¬æ˜¯å†…æ ¸å¯¹åº”ä¸€ä¸ªè¿›ç¨‹çš„ç»“æ„ï¼‰ï¼Œè€Œä¸€ç»„çº¿ç¨‹ä»¥åŠä»–ä»¬æ‰€å…±åŒå¼•ç”¨çš„ä¸€ç»„èµ„æºå°±æ˜¯è¿›ç¨‹ã€‚ä»Linux 2.6å¼€å§‹ï¼Œå†…æ ¸æœ‰äº†çº¿ç¨‹ç»„çš„æ¦‚å¿µï¼Œ***tast_structç»“æ„ä¸­å¢åŠ äº†ä¸€ä¸ª`tgid`ï¼ˆthread group idï¼‰å­—æ®µ***ã€‚`getpid`ï¼ˆè·å–è¿›ç¨‹å·ï¼‰é€šè¿‡ç³»ç»Ÿè°ƒç”¨ã€Œè¿”å›çš„ä¹Ÿæ˜¯tast_structä¸­çš„`tgid`ã€ï¼Œæ‰€ä»¥`tgid`å…¶å®å°±æ˜¯è¿›ç¨‹å·ã€‚è€Œ***tast_structä¸­çš„çº¿ç¨‹å·pidå­—æ®µ***åˆ™ç”±ç³»ç»Ÿè°ƒç”¨`syscall(SYS_gettid)`æ¥è·å–ã€‚

å½“çº¿ç¨‹æ”¶åˆ°ä¸€ä¸ªkillè‡´å‘½ä¿¡å·æ—¶ï¼Œå†…æ ¸ä¼šå°†å¤„ç†åŠ¨ä½œæ–½åŠ åˆ°æ•´ä¸ªçº¿ç¨‹ç»„ä¸Šã€‚ä¸ºäº†åº”ä»˜ã€Œå‘é€ç»™è¿›ç¨‹çš„ä¿¡å·ã€å’Œã€Œå‘é€ç»™çº¿ç¨‹çš„ä¿¡å·ã€ï¼Œtast_structé‡Œé¢*ç»´æŠ¤äº†ä¸¤å¥—signal_pending*ï¼Œä¸€å¥—æ˜¯çº¿ç¨‹ç»„å…±ç”¨çš„ï¼Œä¸€å¥—æ˜¯çº¿ç¨‹ç‹¬æœ‰çš„ã€‚é€šè¿‡***killå‘é€çš„ä¿¡å·è¢«æ”¾åœ¨çº¿ç¨‹ç»„å…±äº«çš„signal_pendingä¸­***ï¼Œå¯ä»¥*ä»»æ„ç”±ä¸€ä¸ªçº¿ç¨‹æ¥å¤„ç†*ã€‚è€Œé€šè¿‡***pthread_killå‘é€çš„ä¿¡å·è¢«æ”¾åœ¨çº¿ç¨‹ç‹¬æœ‰çš„signal_pendingä¸­***ï¼Œåªèƒ½ç”±æœ¬çº¿ç¨‹æ¥å¤„ç†ã€‚

å…³äºçº¿ç¨‹ä¸ä¿¡å·ï¼Œapueæœ‰è¿™ä¹ˆå‡ å¥ï¼š

> æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„ä¿¡å·å±è”½å­—ï¼Œä½†æ˜¯ä¿¡å·çš„å¤„ç†æ˜¯è¿›ç¨‹ä¸­æ‰€æœ‰çº¿ç¨‹å…±äº«çš„ã€‚è¿™æ„å‘³ç€å°½ç®¡å•ä¸ªçº¿ç¨‹å¯ä»¥é˜»æ­¢æŸäº›ä¿¡å·ï¼Œä½†å½“çº¿ç¨‹ä¿®æ”¹äº†ä¸æŸä¸ªä¿¡å·ç›¸å…³çš„å¤„ç†è¡Œä¸ºä»¥åï¼Œæ‰€æœ‰çš„çº¿ç¨‹éƒ½å¿…é¡»å…±äº«è¿™ä¸ªå¤„ç†è¡Œä¸ºçš„æ”¹å˜ã€‚è¿™æ ·å¦‚æœä¸€ä¸ªçº¿ç¨‹é€‰æ‹©å¿½ç•¥æŸä¸ªä¿¡å·ï¼Œè€Œå…¶ä»–çš„çº¿ç¨‹å¯ä»¥æ¢å¤ä¿¡å·çš„é»˜è®¤å¤„ç†è¡Œä¸ºï¼Œæˆ–è€…æ˜¯ä¸ºä¿¡å·è®¾ç½®ä¸€ä¸ªæ–°çš„å¤„ç†ç¨‹åºï¼Œä»è€Œå¯ä»¥æ’¤é”€ä¸Šè¿°çº¿ç¨‹çš„ä¿¡å·é€‰æ‹©ã€‚
> 
> **å¦‚æœä¿¡å·çš„ã€Œé»˜è®¤å¤„ç†åŠ¨ä½œã€æ˜¯ç»ˆæ­¢è¯¥è¿›ç¨‹ï¼Œé‚£ä¹ˆ*æŠŠä¿¡å·ä¼ é€’ç»™æŸä¸ªçº¿ç¨‹ä»ç„¶ä¼šæ€æ‰æ•´ä¸ªè¿›ç¨‹*ã€‚**

ä¾‹å¦‚ä¸€ä¸ªç¨‹åºa.outåˆ›å»ºäº†ä¸€ä¸ªå­çº¿ç¨‹ï¼Œå‡è®¾ä¸»çº¿ç¨‹çš„çº¿ç¨‹å·ä¸º9601ï¼Œå­çº¿ç¨‹çš„çº¿ç¨‹å·ä¸º9602ï¼ˆå®ƒä»¬çš„tgidéƒ½æ˜¯9601ï¼‰ï¼Œå› ä¸ºé»˜è®¤æ²¡æœ‰è®¾ç½®ä¿¡å·å¤„ç†ç¨‹åºï¼Œæ‰€ä»¥å¦‚æœè¿è¡Œå‘½ä»¤kill 9602çš„è¯ï¼Œæ˜¯å¯ä»¥æŠŠ9601å’Œ9602è¿™ä¸ªä¸¤ä¸ªçº¿ç¨‹ä¸€èµ·æ€æ­»çš„ã€‚å¦‚æœä¸çŸ¥é“Linuxçº¿ç¨‹èƒŒåçš„æ•…äº‹ï¼Œå¯èƒ½å°±ä¼šè§‰å¾—é‡åˆ°çµå¼‚äº‹ä»¶äº†ã€‚

å› ä¸ºSIGKILLæ— æ³•è¢«å¿½ç•¥ã€æ•è·ä¸”ä¸å¯æ”¹å˜å…¶é»˜è®¤è¡Œä¸ºï¼šæ€æ­»è¿›ç¨‹ï¼›å› æ­¤æœ€ç»ˆæ— è®ºå“ªä¸ªçº¿ç¨‹å“åº”äº†è¯¥ä¿¡å·ï¼šéƒ½ä¼šå¯¼è‡´è¿›ç¨‹è¢«æ€æ­»ã€‚å®é™…ä¸Šå¯¹äºè¿™ç§æ— æ³•è‡ªå®šä¹‰ç”¨æˆ·å¤„ç†å‡½æ•°çš„ä¿¡å·ï¼Œå†…æ ¸åº”è¯¥ç›´æ¥åœ¨å†…æ ¸æ€ç›´æ¥å®Œæˆå¤„ç†äº†ï¼Ÿ-> å¾—å†çœ‹ä¸€ä¸‹ğŸ‘€

å¦å¤–*ç³»ç»Ÿè°ƒç”¨syscall(SYS_gettid)è·å–çš„çº¿ç¨‹å·ä¸pthread_selfè·å–çš„çº¿ç¨‹å·æ˜¯ä¸åŒçš„*ï¼Œpthread_selfè·å–çš„çº¿ç¨‹å·ä»…ä»…åœ¨çº¿ç¨‹æ‰€ä¾èµ–çš„è¿›ç¨‹å†…éƒ¨å”¯ä¸€ï¼Œåœ¨[pthread_self](http://linux.die.net/man/3/pthread_self)çš„man pageä¸­æœ‰è¿™æ ·ä¸€æ®µè¯ï¼š

> Thread IDs are guaranteed to be unique only within a process. A thread ID may be reused after a terminated thread has been joined, or a detached thread has terminated.

æ‰€ä»¥åœ¨å†…æ ¸ä¸­å”¯ä¸€æ ‡è¯†çº¿ç¨‹IDçš„çº¿ç¨‹å·åªèƒ½é€šè¿‡ç³»ç»Ÿè°ƒç”¨syscall(SYS_gettid)è·å–ã€‚

## ä¸»çº¿ç¨‹é€€å‡ºå¯¹å…¶ä½™çº¿ç¨‹çš„å½±å“
### ä¸»çº¿ç¨‹å…ˆé€€å‡º 
```cpp
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

void* func(void* arg)
{
	pthread_t main_tid = *static_cast<pthread_t*>(arg);
	pthread_cancel(main_tid);
	while (true)
	{
		printf("child loops\n");
	}
	return NULL;
}
int main(int argc, char* argv[])
{
	pthread_t main_tid = pthread_self();
	pthread_t tid = 0;
	pthread_create(&tid, NULL, func, &main_tid);
	while (true)
	{
		printf("main loops\n");
	}
	sleep(1);
	printf("main exit\n");
	return 0;
}
```

æŠŠä¸»çº¿ç¨‹çš„çº¿ç¨‹å·ä¼ ç»™å­çº¿ç¨‹ï¼Œåœ¨å­çº¿ç¨‹ä¸­é€šè¿‡`pthread_cancel`ç»ˆæ­¢ä¸»çº¿ç¨‹ä½¿å…¶é€€å‡ºã€‚è¿è¡Œç¨‹åºï¼Œå¯ä»¥å‘ç°åœ¨æ‰“å°äº†ä¸€å®šæ•°é‡çš„ã€Œmain loopsã€ä¹‹åç¨‹åºå°±æŒ‚èµ·äº†ï¼Œä½†å´æ²¡æœ‰é€€å‡ºã€‚

ä¸»çº¿ç¨‹å› ä¸ºè¢«å­çº¿ç¨‹ç»ˆæ­¢äº†ï¼Œæ‰€æœ‰æ²¡æœ‰çœ‹åˆ°ã€Œmain exitã€çš„æ‰“å°ã€‚å­çº¿ç¨‹ç»ˆæ­¢äº†ä¸»çº¿ç¨‹åè¿›å…¥äº†æ­»å¾ªç¯whileä¸­ï¼Œæ‰€ä»¥ç¨‹åºçœ‹èµ·æ¥åƒæŒ‚èµ·äº†ã€‚å¦‚æœæˆ‘ä»¬è®©å­è¿›ç¨‹whileå¾ªç¯ä¸­çš„æ‰“å°è¯­å¥ç”Ÿæ•ˆå†è¿è¡Œå°±å¯ä»¥å‘ç°ç¨‹åºä¼šä¸€ç›´æ‰“å°ã€Œchild loopsã€å­—æ ·ã€‚

ä¸»çº¿ç¨‹è¢«å­çº¿ç¨‹ç»ˆæ­¢äº†ï¼Œ***ä½†ä»–ä»¬æ‰€ã€Œä¾èµ–çš„è¿›ç¨‹ã€å¹¶æ²¡æœ‰é€€å‡º***ï¼Œæ‰€ä»¥å­çº¿ç¨‹ä¾ç„¶æ­£å¸¸è¿è½¬ã€‚

å¦‚æœä¸»çº¿ç¨‹ä½¿ç”¨`pthread_exit`ä¸»çš„é€€å‡ºï¼Œä¹Ÿä¸ä¼šå¯¼è‡´ã€Œä¾èµ–çš„è¿›ç¨‹ã€é€€å‡ºï¼Œå› æ­¤å…¶ä½™çº¿ç¨‹ä»ç„¶å¤„äºè¿è¡ŒçŠ¶æ€

### ä¸»çº¿ç¨‹éšè¿›ç¨‹ä¸€èµ·é€€å‡º
ä¹‹å‰çœ‹åˆ°ä¸€äº›äººè¯´å¦‚æœä¸»çº¿ç¨‹å…ˆé€€å‡ºäº†ï¼Œå­çº¿ç¨‹ä¹Ÿä¼šè·Ÿç€é€€å‡ºï¼Œå…¶å®ä»–ä»¬æ··æ·†äº†çº¿ç¨‹é€€å‡ºå’Œè¿›ç¨‹é€€å‡ºçš„æ¦‚å¿µã€‚ä¸‹é¢è¿™ä¸ªä¾‹å­ä»£è¡¨äº†ä»–ä»¬çš„è§‚ç‚¹: 
```c
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

void* func(void* arg)
{
	pthread_t main_tid = *static_cast<pthread_t*>(arg);
	while (true)
	{
		printf("child loops\n");
	}
	return NULL;
}
int main(int argc, char* argv[])
{
	pthread_t main_tid = pthread_self();
	pthread_t tid = 0;
	pthread_create(&tid, NULL, func, &main_tid);
	// while (true)
	{
		printf("main loops\n");
	}
	sleep(1);
	printf("main exit\n");
	return 0;
}
```

è¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œä¼šå‘ç°ç¨‹åºåœ¨æ‰“å°ä¸€å®šæ•°é‡çš„ã€Œchild loopsã€å’Œä¸€å¥ã€Œmain exitã€ä¹‹åé€€å‡ºï¼Œå¹¶ä¸”åœ¨é€€å‡ºä¹‹å‰çš„æœ€åä¸€å¥æ‰“å°æ˜¯ã€Œmain exitã€ã€‚

æŒ‰ç…§ä»–ä»¬çš„é€»è¾‘ï¼Œä½ çœ‹ï¼Œå› ä¸ºä¸»çº¿ç¨‹åœ¨æ‰“å°å®Œã€Œmain exitã€åé€€å‡ºäº†ï¼Œç„¶åå­çº¿ç¨‹ä¹Ÿè·Ÿç€é€€å‡ºäº†ï¼Œæ‰€ä»¥éšåå°±æ²¡æœ‰å­çº¿ç¨‹çš„æ‰“å°äº†ã€‚

***ä½†å…¶å®è¿™é‡Œæ˜¯æ··æ·†äº†ã€Œè¿›ç¨‹é€€å‡ºã€å’Œã€Œçº¿ç¨‹é€€å‡ºã€çš„æ¦‚å¿µ***äº†ã€‚å®é™…çš„æƒ…å†µæ˜¯*ä¸»çº¿ç¨‹ä¸­çš„mainå‡½æ•°æ‰§è¡Œå®Œruturnåå¼¹æ ˆ*ï¼Œ***ç„¶åè°ƒç”¨glibcåº“å‡½æ•°ã€Œexitã€ï¼Œexitè¿›è¡Œç›¸å…³æ¸…ç†å·¥ä½œåè°ƒç”¨_exitç³»ç»Ÿè°ƒç”¨é€€å‡ºè¯¥è¿›ç¨‹***ã€‚æ‰€ä»¥ï¼Œè¿™ç§æƒ…å†µ*å®é™…ä¸Šæ˜¯å› ä¸ºè¿›ç¨‹è¿è¡Œå®Œæ¯•é€€å‡ºå¯¼è‡´æ‰€æœ‰çš„çº¿ç¨‹ä¹Ÿéƒ½è·Ÿç€é€€å‡ºäº†*ï¼Œå¹¶éæ˜¯å› ä¸ºä¸»çº¿ç¨‹çš„é€€å‡ºå¯¼è‡´å­çº¿ç¨‹ä¹Ÿé€€å‡ºã€‚

### pthread_exit()
```c
/* Decrease the number of threads. We use an atomic operation to
make sure that only the last thread calls `exit'. */
if (atomic_fetch_add_relaxed (&__pthread_total, -1) == 1)
	/* We are the last thread. */
	exit (0);
```