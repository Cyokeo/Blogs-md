---
title: 内存模型与内存屏障
categories: 嵌入式-架构
---
## 参考
- [深度Linux](https://mp.weixin.qq.com/s/Qi3XSCCgZplm8yY5uDfvAw)
- 

## 内存模型
现代处理器基本上都是支持多发射的，也就是在一个指令周期内可以同时执行多条指令。但是，处理器的资源就那么多，可能不能同时满足处理这些指令的要求。比如，处理器就只有一个加法器，如果同时有两条指令都需要算加法，那么有一条指令必须等待。如果这时候再下一条指令是读取指令，并且和前两条指令无关，那么这条指令将在前面某条加法指令之前完成。还有一种可能，就是前后指令之间具有相关性，比如对同一个地址先读取再写入，后面的写入操作必须等待前面的读取操作完成后才能执行。但是如果这时候第三条指令是写入一个无关的地址，那它可以在前面的写入操作之前被执行，执行顺序再次被打乱了。

所以，***一般情况下指令乱序并不是CPU在执行指令之前刻意去调整顺序***。*CPU总是顺序的去内存里面取指令，然后将其顺序的放入指令流水线*。***但是指令执行时的各种条件，指令与指令之间的相互影响，可能导致顺序放入流水线的指令，最终不是按照放入的顺序执行完成***，在外边看起来仿佛是“乱序”一样，这就是所谓的“顺序流入，乱序流出”。

### 完全存储定序模型
这种内存一致性模型允许对StoreLoad指令组合进行重排序，如果第一条指令是写入，第二条指令是读取，那么有可能在程序看来，读取指令先于写入指令执行。但是，对于其它另外三种指令组合还是可以保证按照顺序执行。
这种模型就相当于前面提到的，在CPU和缓存中间***加入了存储缓冲（store buffer）***，而且这个缓冲还是一个*满足先入先出（FIFO）的队列*。先入先出队列就保证了对StoreStore这种指令组合也能保证按照顺序被感知。***X86架构就是使用的这种内存一致性模型***。

### 部分存储定序模型
这种内存一致性模型除了允许对StoreLoad指令组合进行重排序外，还允许对StoreStore指令组合进行重排序。但是，对于其它另外两种指令组合还是可以保证按照顺序执行。
这种模型就相当于也在CPU和缓存中间加入了存储缓冲，但是这个缓冲不是先入先出的。

### 宽松存储模型
这种内存一致性模型允许对上面说的四种指令组合都进行重排序。
这种模型就相当于前面说的，既有存储缓冲，又有无效队列的情况。

## 内存屏障的使用规则
前面提到过了，读、写内存屏障应该配对使用，或者换做通用内存屏障也需要成对的使用，否则起不到想要的效果。