---
title: cpp-常见的关键字
tags:
  - 面经
---

## static
- 类中静态成员变量/方法，是属于类的；即不创建对象时也可以直接使用
- 类中静态成员变量需要在类外显示的初始化定义
- 会由cpp运行时环境，在程序加载初期进行全局的初始化（包括初始化的全局变量）
	- 编译器在编译每个单元时，会生成一个全局变量、局部静态变量的初始化函数
		- 里面会调用相应的类构造函数
		- 该初始化函数会由cpp运行时环境调用吧！！！
### 静态成员变量
- 静态成员变量的定义必须放在类外：`int child::a = 0;`，且***类外定义时无需加static关键字***进行修饰
- c++语言规定静态成员变量会被默认初始化为0，***类外定义可有可无*** ❌
	- 但是实际上在一些编译器中，如果不加上类外定义，会出现一些不可知的情况，***因此在实际使用中最好在类外加上定义***
- 需要在类外进行显示的初始化 -> 不然编译器会报错
	- ld错误，undefined reference

### 静态成员方法
- 相比于普通成员方法
	- 静态方法不会隐式传递指向具体对象的`this`指针，因此其可以直接通过类来访问
		- 因此静态成员方法中***也不能访问普通成员函数、普通成员变量***
		- 只能访问静态成员变量、静态方法
	- 而普通成员调用时会隐式传递`this`指针
		- 可以访问静态成员变量
		- 可以调用静态成员方法
- 如果在静态成员函数中声明一个静态变量，则该类的所有对象将共享这个静态变量
	- 那如何访问到这个静态变量呢？
	- 无法访问到，只是其它对象在调用该静态方法前，该静态变量的值将保持
	- 也即其它对象也只能在该静态方法中访问到这个静态变量
		- 当然可以通过某些技巧，向外部暴漏这个局部静态变量

### 函数内定义的静态变量 
- 由`__cxa_guard_acquire/release()`保护，只在首次执行函数时进行初始化，且其初始化是线程安全的

## explicit
- [C++ explicit关键字详解](https://www.cnblogs.com/rednodel/p/9299251.html)
- 只需用于类内的单参数构造函数（或者多参数但除了第一个，其它参数都有默认值），这样可以避免编译器的隐式转换
- C11中还可以用于修饰类型转换函数，表示只能进行显示的类型转换

## inline
- 仅从使用的角度考虑这个关键字修饰的函数就可以：一个inline 函数被ODR-use时，其编译单元内必须要有该函数的定义，不论是在头文件中定义，还是在.h文件中定义并包含进来。
- 在 -O0优化等级时，如果编译单元内没有inline的定义，会报⚠️，虽然最终编译能过【含有inline定义的地方为该函数生成了符号】；但是在-O1及以上优化等级时就会报ld的错误
- 因此使用时要符合第一条规则