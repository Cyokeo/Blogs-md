---
title: 动态链接库
categories: 嵌入式-开发
---
## 参考资料
- [7.10 动态链接共享库](https://hansimov.gitbook.io/csapp/part2/ch07-linking/7.10-dynamic-linking-with-shared-libraries)

## 程序编译加载流程
![[Pasted image 20240920214033.png]]

## 描述
基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。认识到这一点是很重要的：此时，***没有任何 libvector.so 的代码和数据节真的被复制到可执行文件 prog2l 中***。反之，链接器***复制了一些重定位和符号表信息***，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。

当加载器加载和运行可执行文件 prog2l 时，它利用 7.9 节中讨论过的技术，加载部分链接的可执行文件 prog2l。接着，它注意到 prog2l 包含一个 `.interp` 节，这一节包含***动态链接器***的路径名，***动态链接器本身就是一个共享目标***（如在 Linux 系统上的 ld-linux.so）。 `加载器`不会像它通常所做地那样将控制传递给应用，而是***加载和运行这个动态链接器***。然后，动态链接器通过执行下面的`重定位`完成链接任务：
- 重定位 libc.so 的文本和数据到某个内存段。
- 重定位 libvector.so 的文本和数据到另一个内存段。
- 重定位 prog2l 中所有对由 libc.so 和 libvector.so 定义的符号的引用。

最后，动态链接器将`控制传递给应用程序`。***从这个时刻开始，共享库的位置就固定了***，并且***在程序执行的过程中都不会改变***。